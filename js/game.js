// Generated by CoffeeScript 1.7.1
(function() {
  var Astar, Game, Map, MapRenderer, highlight,
    __modulo = function(a, b) { return (a % b + +b) % b; };

  Game = (function() {
    Game.prototype.TILE_SIZE = 24;

    function Game(options) {
      this.size = options.size, this.debug = options.debug;
      this.viewport = $('#viewport');
      this.map_renderer = new MapRenderer(this);
    }

    Game.prototype.load_map = function(map) {
      return this.map_renderer.load_map(map);
    };

    return Game;

  })();

  Map = (function() {
    function Map(options) {
      this.name = options.name, this.size = options.size, this.terrain = options.terrain, this.base_tile = options.base_tile;
    }

    return Map;

  })();

  MapRenderer = (function() {
    function MapRenderer(game) {
      this.game = game;
      this.map_element = $('#map');
    }

    MapRenderer.prototype.load_map = function(map) {
      this.map = map;
      return this._render();
    };

    MapRenderer.prototype._render = function() {
      this.map_element.empty();
      this._render_base_tiles();
      if (this.game.debug) {
        return this._render_debug_tiles();
      }
    };

    MapRenderer.prototype._render_base_tiles = function() {
      var base;
      base = $("<div class='base t t" + this.map.base_tile + "'>");
      base.css({
        width: "" + (this.map.size.x * this.game.TILE_SIZE) + "px",
        height: "" + (this.map.size.y * this.game.TILE_SIZE) + "px"
      });
      return this.map_element.append(base);
    };

    MapRenderer.prototype._render_debug_tiles = function() {
      var debug_tiles, idx, tile, _i, _ref;
      debug_tiles = $("<div id='debug-tiles'>");
      for (idx = _i = 0, _ref = (this.map.size.y * this.map.size.x) - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; idx = 0 <= _ref ? ++_i : --_i) {
        tile = $("<div class='d'>");
        tile.data({
          x: __modulo(idx, this.map.size.x) + 1,
          y: Math.floor(idx / this.map.size.x) + 1
        });
        debug_tiles.append(tile);
      }
      debug_tiles.css({
        width: "" + (this.map.size.x * this.game.TILE_SIZE) + "px"
      });
      return this.map_element.append(debug_tiles);
    };

    return MapRenderer;

  })();

  highlight = function(point, colour) {
    return $('div.d').filter(function() {
      var $this;
      $this = $(this);
      return $this.data('y') === point[0] && $this.data('x') === point[1];
    }).css({
      'background': colour
    });
  };

  $(document).ready(function() {
    var astar, first_level, game;
    game = new Game({
      debug: true
    });
    first_level = new Map({
      name: 'first_level',
      size: {
        x: 10,
        y: 10
      },
      terrain: [],
      base_tile: 0
    });
    game.load_map(first_level);
    astar = new Astar({
      grid: [10, 10],
      start: [1, 1],
      end: [5, 5]
    });
    return astar.search();
  });

  Astar = (function() {
    function Astar(options) {
      this.grid = options.grid, this.start = options.start, this.end = options.end;
      highlight(this.start, 'green');
      highlight(this.end, 'red');
      this.open_list = [];
    }

    Astar.prototype.search = function() {
      this.open_list = [this.start];
      console.log("grid = " + this.grid);
      console.log("h = " + (this._heuristic(this.start)));
      return console.log(this._scored_nodes([1, 1]));
    };

    Astar.prototype._heuristic = function(point) {
      return (this.end[0] - point[0]) + (this.end[1] - point[1]);
    };

    Astar.prototype._candidate_nodes = function(point) {
      return [[point[0], point[1] - 1], [point[0], point[1] + 1], [point[0] - 1, point[1]], [point[0] + 1, point[1]]];
    };

    Astar.prototype._suitable_nodes = function(point) {
      var grid;
      grid = this.grid;
      return this._candidate_nodes(point).filter(function(cpoint) {
        return cpoint[0] > 0 && cpoint[1] > 0 && cpoint[0] <= grid[0] && cpoint[1] <= grid[1];
      });
    };

    Astar.prototype._scored_nodes = function(point) {
      var node, scored_nodes, _i, _len, _ref;
      scored_nodes = [];
      _ref = this._suitable_nodes(point);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        scored_nodes.push({
          score: this._heuristic(point),
          point: node,
          parent: point
        });
      }
      return scored_nodes.sort(function(a, b) {
        if (a.score > b.score) {
          return 1;
        } else {
          return -1;
        }
      });
    };

    return Astar;

  })();

}).call(this);
